/* REXX */
/* SET UP DB2 CONSTANTS */
ADDRESS TSO "SUBCOM DB2V13.SDSNLOAD(dsnrexx)"
IF RC<>0 THEN DO
   S_RC=RXSUBCOM('ADD','DSNREXX','DSNREXX')
END
ADDRESS DSNREXX "CONNECT DBD1"
IF SQLCODE<>0 THEN DO
  SAY "DB2 CONNECTION FAILED, SQLCODE="SQLCODE
  EXIT 16
END

/* CONNECTED TO DBD1 */
/* SET UP ISPF TO FIND OUR PANELS, AND GET STARTED */
address tso
"ISPEXEC CONTROL ERRORS RETURN"
app_rc=0
ADDRESS ISPEXEC
"LIBDEF ISPPLIB DATASET ID('PRICE3D.SOURCE.PANELS')"

/* SHOW OUR SPLASH */
"ISPEXEC DISPLAY PANEL (P3DSTART)"
IF RC=8 THEN RETURN

/* MENU LOOP */
/* CHANGED ZCMD TO ZRET BECAUSE ZCMD IS USED BY ISPF */
ZEMSG='Connected to DB2 database.'
DO FOREVER
   CUSTEDIT='' 
   ITEMEDIT='' 
   PROJEDIT='' 
   "ISPEXEC DISPLAY PANEL (PRICE3D)"
   IF RC=8 THEN LEAVE
   SELECT
     WHEN ZRET='1' THEN CALL NEW_FILAMENT_UI
     WHEN ZRET='2' THEN CALL FIL_TABLE
     WHEN ZRET='3' THEN CALL NEW_PROJECT_UI
     WHEN ZRET='4' THEN CALL PROJ_TABLE
     WHEN ZRET="5" THEN CALL NEW_JOB
     WHEN ZRET='8' THEN CALL NEW_CUST
     when ZRET='9' THEN CALL CUST_REPORT
     WHEN ZRET='C' THEN CALL CUST_TABLE
     WHEN ZRET='F' THEN CALL FIL_REPORT
     WHEN ZRET='P' THEN CALL PROJ_REPORT
     WHEN ZRET='X' THEN LEAVE
     WHEN ZRET='x' THEN LEAVE
   OTHERWISE
     ZEMSG="Invalid menu selection.  Try again. (RC="RC") "
   END
   ZRET=''
 END

ADDRESS TSO
ZRET=''

"ISPEXEC LIBDEF ISPPLIB"
"ISPEXEC LIBDEF ISPTLIB"
"ISPEXEC VRESET SHARED"
EXIT APP_RC

/* PROCEDURE CODE */
/* UNIFIED FILAMENT ADD/EDIT LOGIC - MATCHES NEW_CUST PATTERN */
NEW_FILAMENT_UI:
IF STRIP(ITEMEDIT)='' Then DO
  Address ISPEXEC "DISPLAY PANEL(FILMFIND)"
  SAVE_RC=RC
  IF SAVE_RC=8 THEN DO
     ZEMSG="FILAMENT SEARCH CANCELLED."
     CALL RESETFILS
     return
  end
  ITEMEDIT = ITEMID
END
CALL READREC
IF HAVE_REC=0 THEN ITEMID = ITEMEDIT 
Address ISPEXEC "DISPLAY PANEL (PR3DFILM)"
SAVE_RC=RC
if save_rc=8 then do
   zemsg="UPDATE CANCELLED."
   CALL RESETFILS
   return
end
IF STRIP(ITEMID)<>STRIP(ITEMEDIT) THEN DO
   IF HAVE_REC=1 THEN DO
      ZEMSG= "Changing the Item ID is not allowed."
      CALL RESETFILS
      return
   END
END
IF HAVE_REC=0 Then do
   call INSERT_REC
end
ELSE DO
   CALL EDIT_FILAMENT
END
CALL RESETFILS
return

/* UNIFIED PROJECT ADD/EDIT LOGIC - MATCHES NEW_CUST PATTERN */
NEW_PROJECT_UI:
IF STRIP(PROJEDIT)='' Then DO
  Address ISPEXEC "DISPLAY PANEL(PROJFIND)"
  SAVE_RC=RC
  IF SAVE_RC=8 THEN DO
     ZEMSG="PROJECT SEARCH CANCELLED."
     CALL RESETPROJ
     return
  end
  PROJEDIT = PNAME
END
CALL READPROJ
IF HAVE_REC=0 THEN PNAME = PROJEDIT
Address ISPEXEC "DISPLAY PANEL(PR3DPROJ)"
SAVE_RC=RC
if save_rc=8 then do
   zemsg="PROJECT UPDATE CANCELLED."
   CALL RESETPROJ
   return
end
IF HAVE_REC=0 Then do
   call INSERT_PROJ
end
ELSE DO
   CALL EDIT_PROJECT
END
CALL RESETPROJ
return

/* FUNCTIONS */
RESETFILS:
/* RESET ALL FILAMENT VARIABLES TO EMPTY */
   ITEMID=''
   FTYPE=''
   FCOLOR=''
   FWEIGHT=0
   FUSED=0
   FREMAINS=0
   FPRICE=0.00
   FVENDOR=''
   FVENDID=''
   FLINK=''
   FPURCHDT=''
RETURN

RESETPROJ:
/* RESETS ALL PROJECT VARIABLES TO EMPTY */
   PNAME=''
   PFILE=''
   PRUNTIME=0
   PCOSTMIN=0
   PMARKUP=0
   PFIL=''
   PGRAMS=''
return


/* DB2 FUNCTIONS */

SQLEXEC:
  ARG ACCEPT,STMT
  ADDRESS DSNREXX STMT
RETURN

READREC:
HAVE_REC=0
/* GENERATE THE SQL TO READ A RECORD SPECIFIED BY ITEMEDIT */
/* AND RETURN THOSE VALUES INTO THE FILAMENT VARIABLES */
SQLSTMT="SELECT ITEMID,ITTYPE,ITCOLOR,ITWEIGH,ITUSED," ,
        "ITREMAIN,ITPURCH,ITVENDOR,ITVENDORID,ITVREORDER,ITLASTDT",
        "FROM SCOTT.FILMNT WHERE ITEMID='"ITEMEDIT"'"


CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"

CALL SQLEXEC 0,"EXECSQL OPEN C1"


CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"

IF SQLCODE = 0 THEN DO
   /* Row found. Move data to REXX variables. */
   ITEMID=OUTSQLDA.1.SQLDATA
   FTYPE=OUTSQLDA.2.SQLDATA
   FCOLOR=OUTSQLDA.3.SQLDATA
   FWEIGHT=OUTSQLDA.4.SQLDATA
   FUSED=OUTSQLDA.5.SQLDATA
   FREMAINS=OUTSQLDA.6.SQLDATA
   FPRICE=TRUNC(OUTSQLDA.7.SQLDATA,2)
   FVENDOR=OUTSQLDA.8.SQLDATA
   FVENDID=OUTSQLDA.9.SQLDATA
   FLINK=OUTSQLDA.10.SQLDATA
   FPURCHDT=OUTSQLDA.11.SQLDATA
   HAVE_REC=1
END
ELSE IF SQLCODE = 100 THEN DO
   /* Row not found */
   ZEMSG=ITEMEDIT" was not found."
   HAVE_REC=0
END
ELSE DO
   /* Handle other errors */
   ZEMSG='(READREC) SQL ERROR 'SQLCODE ' SQLERRMC:' SQLERRMC
   HAVE_REC=2
END

/* CLOSE the cursor regardless of success/failure */
CALL SQLEXEC 0,"EXECSQL CLOSE C1"
RETURN

READPROJ:
HAVE_REC=0
/* GENERATE THE SQL TO READ A RECORD SPECIFIED BY ITEMEDIT */
/* AND RETURN THOSE VALUES INTO THE PROJECT VARIABLES */
SQLSTMT="SELECT PNAME,PFILE,PRUNTIME,PCOSTMIN,PMARKUP,PFIL,PGRAMS " ,
        "FROM SCOTT.PROJECTS WHERE PNAME='"PROJEDIT"'"


CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"

CALL SQLEXEC 0,"EXECSQL OPEN C1"


CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"

IF SQLCODE = 0 THEN DO
   /* Row found. Move data to REXX variables. */
   PNAME=OUTSQLDA.1.SQLDATA
   PFILE=OUTSQLDA.2.SQLDATA
   PRUNTIME=OUTSQLDA.3.SQLDATA
   PCOSTMIN=OUTSQLDA.4.SQLDATA
   PMARKUP=OUTSQLDA.5.SQLDATA
   PFIL=OUTSQLDA.6.SQLDATA
   PGRAMS=OUTSQLDA.7.SQLDATA
   HAVE_REC=1
END
ELSE IF SQLCODE = 100 THEN DO
   /* Row not found */
   ZEMSG=PROJEDIT" was not found."
   HAVE_REC=0
END
ELSE DO
   /* Handle other errors */
   ZEMSG='(READPROJ) SQL ERROR 'SQLCODE ' SQLERRMC:' SQLERRMC
   HAVE_REC=2
END

/* CLOSE the cursor regardless of success/failure */
CALL SQLEXEC 0,"EXECSQL CLOSE C1"
RETURN

INSERT_REC:
/* GENERATE AND EXECUTE SQL TO INSERT A NEW FILAMENT */
/* USING THE CURRENTLY ACTIVE FILAMENT VARIABLES */
    ADDRESS DSNREXX
    CM = "INSERT INTO SCOTT.FILMNT (ITEMID,ITTYPE,ITCOLOR," ,
         "ITWEIGH,ITUSED,ITREMAIN,ITPURCH,ITVENDOR," ,
         "ITVENDORID,ITVREORDER,ITLASTDT) VALUES(" ,
         "'"ITEMID"','"FTYPE"','"FCOLOR"'," ,
        ""FWEIGHT","FUSED","FREMAINS","TRUNC(FPRICE,2) ,
         ",'"FVENDOR"','"FVENDID"','"FLINK"'," ,
         "DATE '"FPURCHDT"')"
    "EXECSQL "CM
    IF SQLCODE = 0 THEN DO
        "EXECSQL COMMIT"
        ZEMSG=ITEMID" was added to the database."
    END
    ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG="(INSERT) SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
    END
RETURN

INSERT_PROJ:
/* ADD NEW PROJECT RECORD TO DATABASE */
address DSNREXX
CM="INSERT INTO SCOTT.PROJECTS (PNAME,PFILE,PRUNTIME," ,
   "PCOSTMIN,PMARKUP,PFIL,PGRAMS) VALUES(" ,
   "'"PNAME"','"PFILE"',"PRUNTIME","PCOSTMIN","PMARKUP ,
   ",'"PFIL"',"PGRAMS")"
SAY CM
"EXECSQL "CM
IF SQLCODE=0 THEN DO
   "EXECSQL COMMIT"
   ZEMSG=PNAME" was added to the database."
end
else do
   "EXECSQL ROLLBACK"
   ZEMSG="(PROJINS) SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
end
return

READ_CUST:
CUFOUND=0
/* GENERATE THE SQL TO READ A RECORD SPECIFIED BY ITEMEDIT */
/* AND RETURN THOSE VALUES INTO THE CUSTOMER VARIABLES */
SQLSTMT="SELECT CUSTID,CNAME,ADDR1,ADDR2,CITY,STATE,ZIP,PHONE,EMAIL" ,
        " FROM SCOTT.P3DCUST WHERE CUSTID='"CUSTEDIT"'"
CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
CALL SQLEXEC 0,"EXECSQL OPEN C1"
CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
IF SQLCODE = 0 THEN DO
   /* Row found. Move data to REXX variables. */
   CUSTID=OUTSQLDA.1.SQLDATA
   CNAME=OUTSQLDA.2.SQLDATA
   ADDR1=OUTSQLDA.3.SQLDATA
   ADDR2=OUTSQLDA.4.SQLDATA
   CITY=OUTSQLDA.5.SQLDATA
   ST=OUTSQLDA.6.SQLDATA
   ZIP=OUTSQLDA.7.SQLDATA
   PHONE=OUTSQLDA.8.SQLDATA
   EMAIL=OUTSQLDA.9.SQLDATA
   CUFOUND=1
END
ELSE IF SQLCODE = 100 THEN DO
   /* Row not found */
   ZEMSG=CUSTEDIT" was not found."
   CUFOUND=0
END
ELSE DO
   /* Handle other errors */
   ZEMSG='(READCUST) SQL ERROR 'SQLCODE ' SQLERRMC:' SQLERRMC
   HAVE_REC=2
END

/* CLOSE the cursor regardless of success/failure */
CALL SQLEXEC 0,"EXECSQL CLOSE C1"


RETURN

INSERT_CUST:
ADDRESS DSNREXX
CM="INSERT INTO SCOTT.P3DCUST (CUSTID,CNAME,ADDR1,ADDR2,CITY,STATE," ,
   "ZIP,PHONE,EMAIL) VALUES ('"CUSTID"','"CNAME"','"ADDR1"','"ADDR2"','" ,
   ""CITY"','"ST"','"ZIP"','"PHONE"','"EMAIL"')"
"EXECSQL "CM
IF SQLCODE=0 THEN DO
   "EXECSQL COMMIT"
   ZEMSG=CUSTID" was added to the database."
end
else do
   "EXECSQL ROLLBACK"
   ZEMSG="(CUSTINS) SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
end
return



EDIT_FILAMENT:
/* AGGRESSIVE CLEANING OF THE KEY FIELD FROM ISPF PANEL */
CLEAN_ITEMID = STRIP(ITEMID, 'B')
CLEAN_ITEMID = translate(CLEAN_ITEMID)
/* UPDATE THE RECORD WITH ALL CURRENT FILAMENT DATA */
/* NOTE THIS WILL NOT ALLOW THE ITEMID TO BE CHANGED */
CM="UPDATE SCOTT.FILMNT ",
   "SET ITTYPE='"FTYPE"',",
   "ITCOLOR='"FCOLOR"',",
   "ITWEIGH="FWEIGHT",",
   "ITUSED="FUSED",",
   "ITREMAIN="FREMAINS",",
   "ITPURCH="TRUNC(FPRICE,2)",",
   "ITVENDOR='"FVENDOR"',",
   "ITVENDORID='"FVENDID"',",
   "ITVREORDER='"FLINK"',",
   "ITLASTDT=DATE '"FPURCHDT"'",
   "WHERE RTRIM(ITEMID)='"CLEAN_ITEMID"'"
ADDRESS DSNREXX
"EXECSQL "CM
IF SQLCODE = 0 THEN DO
    /* Check if any rows were affected */
    IF SQLERRD.3 > 0 THEN DO
        UPDROWS=SQLERRD.3
        "EXECSQL COMMIT"
        ZEMSG="("UPDROWS") updated."
    END
    ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG="UPDATE FAILED: ITEMID '"ITEMID"' NOT FOUND. ("SQLERRD.3")"
    END
END
ELSE DO
    /* Handle SQL error */
    "EXECSQL ROLLBACK"
    ZEMSG="SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
END
RETURN

EDIT_PROJECT:
/* AGGRESSIVE CLEANING OF THE KEY FIELD FROM ISPF PANEL */
CLEAN_PNAME = STRIP(PNAME, 'B')
CLEAN_PNAME = translate(CLEAN_PNAME)
/* UPDATE THE RECORD WITH ALL CURRENT PROJECT DATA */
/* NOTE THIS WILL NOT ALLOW THE PNAME TO BE CHANGED */
CM="UPDATE SCOTT.PROJECTS ",
   "SET",
   "PFILE='"PFILE"',",
   "PRUNTIME="PRUNTIME",",
   "PCOSTMIN="PCOSTMIN",",
   "PMARKUP="PMARKUP",",
   "PFIL='"PFIL"',",
   "PGRAMS="PGRAMS ,
   "WHERE RTRIM(PNAME)='"CLEAN_PNAME"'"
ADDRESS DSNREXX
"EXECSQL "CM
IF SQLCODE = 0 THEN DO
    /* Check if any rows were affected */
    IF SQLERRD.3 > 0 THEN DO
        UPDROWS=SQLERRD.3
        "EXECSQL COMMIT"
        ZEMSG="("UPDROWS") updated."
    END
    ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG="UPDATE FAILED: PROJECT '"PNAME"' NOT FOUND. ("SQLERRD.3")"
    END
END
ELSE DO
    /* Handle SQL error */
    "EXECSQL ROLLBACK"
    ZEMSG="SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
END
RETURN

RESET_CUST:
CUSTID=''
CNAME=''
ADDR1=''
ADDR2=''
CITY=''
ST=''
ZIP=''
PHONE=''
EMAIL=''
CUSTEDIT=''
CUFOUND=0
return

EDIT_CUST:
/* AGGRESSIVE CLEANING OF THE KEY FIELD FROM ISPF PANEL */
CLEAN_CUSTID = STRIP(CUSTID, 'B')
CLEAN_CUSTID = translate(CLEAN_CUSTID)
/* UPDATE THE RECORD WITH ALL CURRENT CUSTOMER DATA */
/* NOTE THIS WILL NOT ALLOW THE CUSTID TO BE CHANGED */
CM="UPDATE SCOTT.P3DCUST ",
   "SET",
   "CNAME='"CNAME"',",
   "ADDR1='"ADDR1"',",
   "ADDR2='"ADDR2"',",
   "CITY='"CITY"',",
   "STATE='"ST"',",
   "ZIP='"ZIP"',",
   "PHONE='"PHONE"',",
   "EMAIL='"EMAIL"'",
   "WHERE RTRIM(CUSTID)='"CLEAN_CUSTID"'"
ADDRESS DSNREXX

"EXECSQL "CM


IF SQLCODE = 0 THEN DO
    /* Check if any rows were affected */
    IF SQLERRD.3 > 0 THEN DO
        UPDROWS=SQLERRD.3
        "EXECSQL COMMIT"
        ZEMSG="("UPDROWS") updated."
    END
    ELSE DO
        /* Handles those weird times when the update doesn't actually update */
        "EXECSQL ROLLBACK" /* Still a good practice */
        ZEMSG="UPDATE FAILED: CUSTID '"CUSTID"' NOT FOUND. ("SQLERRD.3")"
    END
END
ELSE DO
    /* Handle SQL error */
    "EXECSQL ROLLBACK"
    ZEMSG="SQL ERROR "SQLCODE " SQLERRMC:" SQLERRMC
END
RETURN

NEW_JOB:
Address ISPEXEC "DISPLAY PANEL(PD3JOB)"
SAVE_RC = RC
IF SAVE_RC = 8 THEN DO
   ZEMSG = "NEW JOB CANCELLED."
   RETURN
   end
else do
  SAY SAVE_RC
END
RETURN

NEW_CUST:

IF STRIP(CUSTEDIT)='' Then DO
Address ISPEXEC "DISPLAY PANEL(P3DCUENT)"
SAVE_RC=RC
IF SAVE_RC=8 THEN DO
   ZEMSG="NEW CUSTOMER CANCELLED."
   CALL RESET_CUST
   return
end
END
/* DO THE LOOKUP AND RETURN CUFOUND AS 1 IF IT'S EXISTING */
/* OTHERWISE RETURN CUFOUND=0 */
CUSTEDIT=CUSTID
CALL READ_CUST
Address ISPEXEC "DISPLAY PANEL(P3DCUST)"
SAVE_RC=RC
if save_rc=8 then do
   zemsg="CUSTOMER UPDATE CANCELLED."
   CALL RESET_CUST
   return
end
IF CUFOUND=0 Then do
   call INSERT_CUST
end
ELSE DO
   CALL EDIT_CUST
END
CALL RESET_CUST
return

CUST_REPORT:
out_dd = "REPORT"

Address TSO "ALLOCATE FI("out_dd") SYSOUT(A)"
IF RC<>0 Then SAY "ALLOCATE RC="RC
 /* Initialize Pagination */
  PAGE_NUM   = 0
  LINE_COUNT = 99
  MAX_LINES  = 55
  OFFSET     = COPIES(" ", 12) /* Align below CNAME column */
  TOT_RECS   = 0
  SQLSTMT="SELECT * FROM SCOTT.P3DCUST"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"

  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave

    CUSTID = OUTSQLDA.1.SQLDATA
    CNAME  = OUTSQLDA.2.SQLDATA
    ADDR1  = OUTSQLDA.3.SQLDATA
    ADDR2  = OUTSQLDA.4.SQLDATA
    CITY   = OUTSQLDA.5.SQLDATA
    ST     = OUTSQLDA.6.SQLDATA
    ZIP    = OUTSQLDA.7.SQLDATA
    PHONE  = OUTSQLDA.8.SQLDATA
    EMAIL  = OUTSQLDA.9.SQLDATA


    if LINE_COUNT + 4 > MAX_LINES then do
       PAGE_NUM = PAGE_NUM + 1

       out_line.1 = CENTER("CUSTOMER CONTACT & ADDRESS REPORT", 120) || "PAGE:" || RIGHT(PAGE_NUM, 3)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 132)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."


       out_line.1 = LEFT("CUST-ID", 12) || LEFT("NAME", 30) || LEFT("PHONE", 20) || "EMAIL"
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 132)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

       LINE_COUNT = 4
    end


    out_line.1 = LEFT(CUSTID, 12) || LEFT(CNAME, 30) || LEFT(PHONE, 20) || EMAIL
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."


    out_line.1 = OFFSET || ADDR1
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."


    if STRIP(ADDR2) \= "" then out_line.1 = OFFSET || ADDR2
    else out_line.1 = " "
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."


    out_line.1 = OFFSET || STRIP(CITY) || ", " || ST || "  " || ZIP
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."


    out_line.1 = " "
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
    TOT_RECS=TOT_RECS+1
    LINE_COUNT = LINE_COUNT + 5
  end
  out_line.1 = COPIES("=", 132)
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
  out_line.1 = "TOTAL RECORDS PROCESSED: " || TOT_RECS
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
  address TSO "EXECIO 0 DISKW" out_dd "(FINIS)"
  address TSO "FREE FI("out_dd")"
  zemsg="CUSTOMER REPORT SENT TO CLASS A PRINTER."
RETURN 0


FIL_REPORT:
out_dd = "REPORT"

Address TSO "ALLOCATE FI("out_dd") SYSOUT(A)"
IF RC<>0 Then SAY "ALLOCATE RC="RC
 /* Initialize Pagination */
  PAGE_NUM   = 0
  LINE_COUNT = 99
  MAX_LINES  = 55
  TOT_RECS   = 0
  SQLSTMT="SELECT ITEMID, ITTYPE, ITCOLOR, ITWEIGH, ITREMAIN, ITPURCH FROM SCOTT.FILMNT"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"

  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave

    ITEMID   = OUTSQLDA.1.SQLDATA
    FTYPE    = OUTSQLDA.2.SQLDATA
    FCOLOR   = OUTSQLDA.3.SQLDATA
    FWEIGHT  = OUTSQLDA.4.SQLDATA
    FREMAIN  = OUTSQLDA.5.SQLDATA
    FPRICE   = OUTSQLDA.6.SQLDATA

    if LINE_COUNT + 2 > MAX_LINES then do
       PAGE_NUM = PAGE_NUM + 1

       out_line.1 = CENTER("FILAMENT INVENTORY REPORT", 80) || "PAGE:" || RIGHT(PAGE_NUM, 3)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 100)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

       out_line.1 = LEFT("ITEM ID", 20) || LEFT("TYPE", 8) || LEFT("COLOR", 12) || RIGHT("WEIGHT", 8) || RIGHT("REM(g)", 8) || RIGHT("PRICE", 10)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 100)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

       LINE_COUNT = 4
    end

    out_line.1 = LEFT(ITEMID, 20) || LEFT(FTYPE, 8) || LEFT(FCOLOR, 12) || RIGHT(FWEIGHT, 8) || RIGHT(FREMAIN, 8) || RIGHT(FPRICE, 10)
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

    TOT_RECS=TOT_RECS+1
    LINE_COUNT = LINE_COUNT + 1
  end
  out_line.1 = COPIES("=", 100)
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
  out_line.1 = "TOTAL FILAMENTS: " || TOT_RECS
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

  /* Use generic cursor close */
  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
  address TSO "EXECIO 0 DISKW" out_dd "(FINIS)"
  address TSO "FREE FI("out_dd")"
  zemsg="FILAMENT REPORT SENT TO CLASS A PRINTER."
RETURN 0

PROJ_REPORT:
out_dd = "REPORT"

Address TSO "ALLOCATE FI("out_dd") SYSOUT(A)"
IF RC<>0 Then SAY "ALLOCATE RC="RC
 /* Initialize Pagination */
  PAGE_NUM   = 0
  LINE_COUNT = 99
  MAX_LINES  = 55
  TOT_RECS   = 0
  SQLSTMT="SELECT PNAME, PFILE, PGRAMS, PRUNTIME, PCOSTMIN FROM SCOTT.PROJECTS"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"

  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave

    PNAME    = OUTSQLDA.1.SQLDATA
    PFILE    = OUTSQLDA.2.SQLDATA
    PGRAMS   = OUTSQLDA.3.SQLDATA
    PRUNTIME = OUTSQLDA.4.SQLDATA
    PCOST    = OUTSQLDA.5.SQLDATA

    if LINE_COUNT + 2 > MAX_LINES then do
       PAGE_NUM = PAGE_NUM + 1

       out_line.1 = CENTER("PROJECT LISTING REPORT", 80) || "PAGE:" || RIGHT(PAGE_NUM, 3)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 100)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

       out_line.1 = LEFT("PROJECT NAME", 20) || LEFT("FILENAME", 20) || RIGHT("GRAMS", 8) || RIGHT("TIME(m)", 8) || RIGHT("COST", 10)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
       out_line.1 = COPIES("-", 100)
       address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

       LINE_COUNT = 4
    end

    out_line.1 = LEFT(PNAME, 20) || LEFT(PFILE, 20) || RIGHT(PGRAMS, 8) || RIGHT(PRUNTIME, 8) || RIGHT(PCOST, 10)
    address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

    TOT_RECS=TOT_RECS+1
    LINE_COUNT = LINE_COUNT + 1
  end
  out_line.1 = COPIES("=", 100)
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."
  out_line.1 = "TOTAL PROJECTS: " || TOT_RECS
  address TSO "EXECIO 1 DISKW" out_dd "(STEM out_line."

  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
  address TSO "EXECIO 0 DISKW" out_dd "(FINIS)"
  address TSO "FREE FI("out_dd")"
  zemsg="PROJECT REPORT SENT TO CLASS A PRINTER."
RETURN 0


CUST_TABLE: PROCEDURE
  ADDRESS ISPEXEC

  do forever

    CALL LOAD_DATA
    "TBTOP CUSTBL"


    SEL = ""
    "VPUT(SEL) SHARED"


    do forever
      "TBDISPL CUSTBL PANEL(P3DCUTBL)"
      DISP_RC = RC


      if DISP_RC >= 8 then return 0


      if ZTDSELS > 0 then do

         "VGET(SEL CUSTID CNAME)"

         SELECT
           WHEN SEL = 'S' THEN CALL SHOW_REC
           WHEN SEL = 'E' THEN CALL EDIT_REC
           WHEN SEL = 'D' THEN CALL DELETE_CUST
           OTHERWISE NOP
         END


         leave
      end

    end
  end
RETURN 0


LOAD_DATA:
  "TBSTATS CUSTBL"
  if RC = 0 then "TBEND CUSTBL"

  "TBCREATE CUSTBL NAMES(CUSTID CNAME CITY STATE) NOWRITE"

  SQLSTMT = "SELECT CUSTID, CNAME, CITY, STATE FROM SCOTT.P3DCUST"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"

  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave

    CUSTID = OUTSQLDA.1.SQLDATA
    CNAME  = OUTSQLDA.2.SQLDATA
    CITY   = OUTSQLDA.3.SQLDATA
    ST     = OUTSQLDA.4.SQLDATA

    SEL = ""
    "TBADD CUSTBL"
  end
  if SQLCODE \= 100 & SQLCODE \= 0 then ZEMSG = "LOAD ERROR: "SQLCODE
  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
RETURN


SHOW_REC:
   SAY "SHOWING:" STRIP(CNAME)
RETURN

EDIT_REC:
   CUSTEDIT= STRIP(CUSTID)
   CALL NEW_CUST
RETURN

DELETE_REC:
   SAY "DELETING:" STRIP(CUSTID)
RETURN

FIL_TABLE: PROCEDURE
  ADDRESS ISPEXEC
  do forever
    CALL LOAD_FIL_DATA
    "TBTOP FILTBL"
    SEL = ""
    "VPUT(SEL) SHARED"
    do forever
      "TBDISPL FILTBL PANEL(PR3DFTBL)"
      DISP_RC = RC
      if DISP_RC >= 8 then return 0
      if ZTDSELS > 0 then do
         "VGET(SEL ITEMID FTYPE FCOLOR FWEIGHT)"
         SELECT
           WHEN (SEL = 'S' | SEL = 'E') THEN DO
              ITEMEDIT = STRIP(ITEMID)
              CALL NEW_FILAMENT_UI
           END
           WHEN SEL = 'D' THEN CALL DELETE_FILAMENT
           OTHERWISE NOP
         END
         leave
      end
    end
  end
RETURN 0

LOAD_FIL_DATA:
  ZEMSG = ""
  "TBSTATS FILTBL"
  if RC = 0 then "TBEND FILTBL"
  "TBCREATE FILTBL NAMES(ITEMID FTYPE FCOLOR FWEIGHT) NOWRITE"
  SQLSTMT = "SELECT ITEMID, ITTYPE, ITCOLOR, ITWEIGH FROM SCOTT.FILMNT"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"
  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave
    ITEMID  = OUTSQLDA.1.SQLDATA
    FTYPE   = OUTSQLDA.2.SQLDATA
    FCOLOR  = OUTSQLDA.3.SQLDATA
    FWEIGHT = OUTSQLDA.4.SQLDATA
    SEL = ""
    "TBADD FILTBL"
  end
  if SQLCODE \= 100 & SQLCODE \= 0 then ZEMSG = "LOAD FIL ERROR: "SQLCODE
  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
RETURN

PROJ_TABLE: PROCEDURE
  ADDRESS ISPEXEC
  do forever
    CALL LOAD_PROJ_DATA
    "TBTOP PROJTBL"
    SEL = ""
    "VPUT(SEL) SHARED"
    do forever
      "TBDISPL PROJTBL PANEL(PR3DPTBL)"
      DISP_RC = RC
      if DISP_RC >= 8 then return 0
      if ZTDSELS > 0 then do
         "VGET(SEL PNAME PFILE PGRAMS)"
         SELECT
           WHEN (SEL = 'S' | SEL = 'E') THEN DO
              PROJEDIT = STRIP(PNAME)
              CALL NEW_PROJECT_UI
           END
           WHEN SEL = 'D' THEN CALL DELETE_PROJECT
           OTHERWISE NOP
         END
         leave
      end
    end
  end
RETURN 0

LOAD_PROJ_DATA:
  ZEMSG = ""
  "TBSTATS PROJTBL"
  if RC = 0 then "TBEND PROJTBL"
  "TBCREATE PROJTBL NAMES(PNAME PFILE PGRAMS) NOWRITE"
  SQLSTMT = "SELECT PNAME, PFILE, PGRAMS FROM SCOTT.PROJECTS"
  CALL SQLEXEC 0,"EXECSQL DECLARE C1 CURSOR FOR S1"
  CALL SQLEXEC 0,"EXECSQL PREPARE S1 INTO :OUTSQLDA FROM :SQLSTMT"
  CALL SQLEXEC 0,"EXECSQL OPEN C1"
  do forever
    CALL SQLEXEC 0,"EXECSQL FETCH C1 USING DESCRIPTOR :OUTSQLDA"
    if SQLCODE = 100 then leave
    if SQLCODE < 0 then leave
    PNAME  = OUTSQLDA.1.SQLDATA
    PFILE  = OUTSQLDA.2.SQLDATA
    PGRAMS = OUTSQLDA.3.SQLDATA
    SEL = ""
    "TBADD PROJTBL"
  end
  if SQLCODE \= 100 & SQLCODE \= 0 then ZEMSG = "LOAD PROJ ERROR: "SQLCODE
  CALL SQLEXEC 0,"EXECSQL CLOSE C1"
RETURN

DELETE_CUST:
  ZCONFMSG = "CUSTOMER: " || STRIP(CUSTID) || " (" || STRIP(CNAME) || ")"
  IF CONFIRM_DEL() = 1 THEN DO
     ADDRESS DSNREXX "EXECSQL DELETE FROM SCOTT.P3DCUST WHERE CUSTID='"STRIP(CUSTID)"'"
     IF SQLCODE = 0 THEN DO
        "EXECSQL COMMIT"
        ZEMSG = "Customer " || CUSTID || " deleted."
     END
     ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG = "SQL Error: " || SQLCODE
     END
  END
RETURN

DELETE_FILAMENT:
  ZCONFMSG = "FILAMENT: " || STRIP(ITEMID) || " (" || STRIP(FCOLOR) || " " || STRIP(FTYPE) || ")"
  IF CONFIRM_DEL() = 1 THEN DO
     ADDRESS DSNREXX "EXECSQL DELETE FROM SCOTT.FILMNT WHERE ITEMID='"STRIP(ITEMID)"'"
     IF SQLCODE = 0 THEN DO
        "EXECSQL COMMIT"
        ZEMSG = "Filament " || ITEMID || " deleted."
     END
     ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG = "SQL Error: " || SQLCODE
     END
  END
RETURN

DELETE_PROJECT:
  ZCONFMSG = "PROJECT: " || STRIP(PNAME)
  IF CONFIRM_DEL() = 1 THEN DO
     ADDRESS DSNREXX "EXECSQL DELETE FROM SCOTT.PROJECTS WHERE PNAME='"STRIP(PNAME)"'"
     IF SQLCODE = 0 THEN DO
        "EXECSQL COMMIT"
        ZEMSG = "Project " || PNAME || " deleted."
     END
     ELSE DO
        "EXECSQL ROLLBACK"
        ZEMSG = "SQL Error: " || SQLCODE
     END
  END
RETURN

CONFIRM_DEL:
  ADDRESS ISPEXEC "DISPLAY PANEL(P3DCONF)"
  IF RC = 0 THEN RETURN 1
  RETURN 0
